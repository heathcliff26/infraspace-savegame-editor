
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gui: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/infraspace-savegame-editor/pkg/gui/app.go (34.8%)</option>
				
				<option value="file1">github.com/heathcliff26/infraspace-savegame-editor/pkg/gui/utils.go (39.1%)</option>
				
				<option value="file2">github.com/heathcliff26/infraspace-savegame-editor/pkg/save/errors.go (0.0%)</option>
				
				<option value="file3">github.com/heathcliff26/infraspace-savegame-editor/pkg/save/json.go (78.3%)</option>
				
				<option value="file4">github.com/heathcliff26/infraspace-savegame-editor/pkg/save/save.go (0.0%)</option>
				
				<option value="file5">github.com/heathcliff26/infraspace-savegame-editor/pkg/save/utils.go (87.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package gui

import (
        "fmt"
        "image/color"
        "os"
        "path/filepath"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/app"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/data/binding"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/storage"
        "fyne.io/fyne/v2/widget"
        "github.com/heathcliff26/infraspace-savegame-editor/pkg/save"
        "github.com/heathcliff26/infraspace-savegame-editor/pkg/version"
)

var (
        TEXT_COLOR   = color.White
        BORDER_COLOR = color.White
)

const (
        ENTRY_WIDTH = 120
        BORDER_SIZE = 1
)

type GUI struct {
        App               fyne.App
        Main              fyne.Window
        Title             string
        Menu              *fyne.MainMenu
        Save              *save.Savegame
        Backup            bool
        Resources         []Resource
        Research          []ResearchItem
        UnlockAllResearch *widget.Check
        OtherOptions      OtherOptions
        ActionButtons     []*widget.Button
}

func New() *GUI <span class="cov0" title="0">{
        a := app.New()
        title := version.Version().Name
        main := a.NewWindow(title)
        g := &amp;GUI{
                App:    a,
                Main:   main,
                Title:  title,
                Backup: true,
        }

        g.Main.SetMainMenu(g.makeMenu())

        resourcesBox := g.makeResourcesBox()
        researchBox := g.makeResearchBox()
        optionsBox := g.makeOptionsBox()
        actionButtons := g.makeActionButtons()
        g.Main.SetContent(container.NewVBox(resourcesBox, researchBox, optionsBox, actionButtons))
        g.Main.SetFixedSize(true)

        g.Main.Show()

        return g
}</span>

func (g *GUI) Run() <span class="cov0" title="0">{
        g.App.Run()
}</span>

func (g *GUI) DisplayError(err error) <span class="cov0" title="0">{
        dialog.ShowError(err, g.Main)
}</span>

func (g *GUI) loadSavegame(uri fyne.URIReadCloser, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                g.DisplayError(err)
                return
        }</span>
        <span class="cov0" title="0">if uri == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">path := uri.URI().Path()
        g.Save, err = save.LoadSavegame(path)
        if err != nil </span><span class="cov0" title="0">{
                g.DisplayError(err)
                return
        }</span>

        <span class="cov0" title="0">g.ReloadFromSave()
        fmt.Println("Successfully loaded save file: " + path)

        newTitle := g.Title + " - " + filepath.Base(path)
        fmt.Println("Setting title to: " + newTitle) // Leaving this here for debug, since it keeps panicking here
        g.Main.SetTitle(newTitle)
        for _, b := range g.ActionButtons </span><span class="cov0" title="0">{
                b.Enable()
        }</span>
}

func (g *GUI) writeSavegame() <span class="cov0" title="0">{
        abortDialog := func(err error) </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Encountered an error while saving: %v. No changes have been written to the save-file", err)
                dialog.NewInformation("Error", msg, g.Main).Show()
        }</span>

        <span class="cov0" title="0">for _, resource := range g.Resources </span><span class="cov0" title="0">{
                value, err := resource.Value.Get()
                if err != nil </span><span class="cov0" title="0">{
                        abortDialog(err)
                        return
                }</span>
                <span class="cov0" title="0">err = g.Save.SetResource(resource.Name, value)
                if err != nil </span><span class="cov0" title="0">{
                        abortDialog(err)
                        return
                }</span>
        }

        <span class="cov0" title="0">if g.UnlockAllResearch.Checked </span><span class="cov0" title="0">{
                g.Save.UnlockAllResearch()
        }</span> else<span class="cov0" title="0"> {
                for _, research := range g.Research </span><span class="cov0" title="0">{
                        if research.Checkbox.Checked </span><span class="cov0" title="0">{
                                g.Save.UnlockResearch(research.Name)
                        }</span> else<span class="cov0" title="0"> {
                                g.Save.LockResearch(research.Name)
                        }</span>
                }
        }

        <span class="cov0" title="0">starterWorkerCount, err := g.OtherOptions.StarterWorker.Value.Get()
        if err != nil </span><span class="cov0" title="0">{
                abortDialog(err)
                return
        }</span>
        <span class="cov0" title="0">if starterWorkerCount &gt; g.Save.GetStarterWorkerCount() </span><span class="cov0" title="0">{
                g.Save.AddStarterWorkers(starterWorkerCount)
        }</span>

        <span class="cov0" title="0">buildingOptions := save.EditBuildingsOptions{
                HabitatWorkers: g.OtherOptions.HabitatWorkers.Checked,
                HabitatStorage: g.OtherOptions.HabitatStorage.Checked,
                FactoryStorage: g.OtherOptions.FactoryStorage.Checked,
                UpgradesOnly:   g.OtherOptions.UpgradesOnly.Checked,
        }
        g.Save.EditBuildings(buildingOptions)

        if g.Save.Changed </span><span class="cov0" title="0">{
                if g.Backup </span><span class="cov0" title="0">{
                        path, err := g.Save.Backup()
                        if err != nil </span><span class="cov0" title="0">{
                                abortDialog(err)
                                return
                        }</span>
                        <span class="cov0" title="0">dialog.NewInformation("Created Backup", "Created backup of save at "+path, g.Main).Show()</span>
                }

                <span class="cov0" title="0">err = g.Save.Save()
                if err != nil </span><span class="cov0" title="0">{
                        abortDialog(err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                dialog.NewInformation("Info", "Please make some changes first.", g.Main).Show()
        }</span>
}

func (g *GUI) ReloadFromSave() <span class="cov0" title="0">{
        for _, resource := range g.Resources </span><span class="cov0" title="0">{
                value, ok := g.Save.GetResource(resource.Name)
                if !ok </span><span class="cov0" title="0">{
                        g.DisplayError(fmt.Errorf("unkown resource name: %s", resource.Name))
                }</span>
                <span class="cov0" title="0">err := resource.Value.Set(value)
                if err != nil </span><span class="cov0" title="0">{
                        g.DisplayError(err)
                        return
                }</span>
                <span class="cov0" title="0">resource.Entry.Refresh()</span>
        }

        <span class="cov0" title="0">unlockedResearch := g.Save.GetUnlockedResearch()
        for _, item := range g.Research </span><span class="cov0" title="0">{
                item.Checkbox.Enable()
                for _, name := range unlockedResearch </span><span class="cov0" title="0">{
                        if name == item.Checkbox.Text </span><span class="cov0" title="0">{
                                item.Checkbox.Checked = true
                                item.Checkbox.Refresh()
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">g.UnlockAllResearch.Checked = false
        g.UnlockAllResearch.Refresh()

        err := g.OtherOptions.StarterWorker.Value.Set(g.Save.GetStarterWorkerCount())
        if err != nil </span><span class="cov0" title="0">{
                g.DisplayError(err)
                return
        }</span>
        <span class="cov0" title="0">g.OtherOptions.StarterWorker.Entry.Refresh()</span>
}

func (g *GUI) makeMenu() *fyne.MainMenu <span class="cov8" title="1">{
        loadSavegame := func() </span><span class="cov0" title="0">{
                dir, err := save.DefaultSaveLocation()
                if !version.RELEASE </span><span class="cov0" title="0">{
                        // When developing, you likely have a copy of the save in the current directory
                        dir, err = os.Getwd()
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        g.DisplayError(err)
                        return
                }</span>

                <span class="cov0" title="0">uri, err := storage.ParseURI("file://" + dir)
                if err != nil </span><span class="cov0" title="0">{
                        g.DisplayError(fmt.Errorf("failed to create URI from Path \"%s\": %v", dir, err))
                        return
                }</span>

                <span class="cov0" title="0">listURI, err := storage.ListerForURI(uri)
                if err != nil </span><span class="cov0" title="0">{
                        g.DisplayError(err)
                        return
                }</span>

                <span class="cov0" title="0">dialog := dialog.NewFileOpen(g.loadSavegame, g.Main)
                dialog.SetLocation(listURI)
                dialog.SetFilter(storage.NewExtensionFileFilter([]string{".sav"}))
                dialog.Resize(fyne.NewSize(800, 600))
                dialog.Show()</span>
        }
        <span class="cov8" title="1">openSave := fyne.NewMenuItem("Load Save", loadSavegame)

        backup := fyne.NewMenuItem("Backup", nil)
        backup.Checked = g.Backup
        backup.Action = func() </span><span class="cov0" title="0">{
                backup.Checked = !backup.Checked
                g.Backup = backup.Checked
                g.Menu.Refresh()
        }</span>

        <span class="cov8" title="1">fileMenu := fyne.NewMenu("File", openSave, fyne.NewMenuItemSeparator(), backup)

        about := fyne.NewMenuItem("About", nil)
        about.Action = func() </span><span class="cov0" title="0">{
                vInfo := dialog.NewCustom(g.Title, "close", getVersionContent(), g.Main)
                vInfo.Show()
        }</span>

        <span class="cov8" title="1">helpMenu := fyne.NewMenu("Help", about)

        g.Menu = fyne.NewMainMenu(fileMenu, helpMenu)
        return g.Menu</span>
}

type Resource struct {
        Name  string
        Value binding.Int
        Entry *widget.Entry
}

func (g *GUI) makeResourcesBox() fyne.CanvasObject <span class="cov8" title="1">{
        resources := []Resource{{Name: "concrete"}, {Name: "steel"}, {Name: "car"}, {Name: "adamantine"}}

        content := make([]fyne.CanvasObject, len(resources))
        for i := 0; i &lt; len(resources); i++ </span><span class="cov8" title="1">{
                label := canvas.NewText(resources[i].Name+": ", TEXT_COLOR)
                resources[i].Value = binding.NewInt()
                resources[i].Entry = widget.NewEntryWithData(binding.IntToString(resources[i].Value))
                r := resources[i]
                button := widget.NewButton("1 mio.", func() </span><span class="cov0" title="0">{
                        err := r.Value.Set(1000000)
                        if err != nil </span><span class="cov0" title="0">{
                                dialog.NewError(err, g.Main).Show()
                                return
                        }</span>
                        <span class="cov0" title="0">r.Entry.Refresh()</span>
                })
                <span class="cov8" title="1">size := resources[i].Entry.MinSize()
                size.Width = ENTRY_WIDTH
                wrappedEntry := container.NewGridWrap(size, resources[i].Entry)
                content[i] = container.NewHBox(label, wrappedEntry, button)</span>
        }

        <span class="cov8" title="1">g.Resources = resources
        return newBorder(container.NewGridWithColumns(len(content), content...))</span>
}

type ResearchItem struct {
        Name     string
        Checkbox *widget.Check
}

func (g *GUI) makeResearchBox() fyne.CanvasObject <span class="cov8" title="1">{
        researchNames := save.ResearchNames()
        items := make([]ResearchItem, len(researchNames))
        widgets := make([]fyne.CanvasObject, len(researchNames))
        for i := 0; i &lt; len(researchNames); i++ </span><span class="cov8" title="1">{
                items[i] = ResearchItem{Name: researchNames[i]}
                items[i].Checkbox = widget.NewCheck(researchNames[i], nil)
                widgets[i] = items[i].Checkbox
        }</span>
        <span class="cov8" title="1">g.Research = items

        rows := make([]fyne.CanvasObject, 0, (len(widgets)/10)+1)
        for i := 0; i &lt; len(widgets); </span><span class="cov8" title="1">{
                row := make([]fyne.CanvasObject, 0, 10)
                for x := 0; x &lt; 10; x++ </span><span class="cov8" title="1">{
                        if i &lt; len(widgets) </span><span class="cov8" title="1">{
                                row = append(row, widgets[i])
                                i++
                        }</span> else<span class="cov8" title="1"> {
                                row = append(row, layout.NewSpacer())
                                break</span>
                        }
                }
                <span class="cov8" title="1">rows = append(rows, container.NewVBox(row...))</span>
        }
        <span class="cov8" title="1">researchGrid := newBorder(container.NewHBox(rows...))

        changedUnlockAll := func(checked bool) </span><span class="cov8" title="1">{
                for _, item := range g.Research </span><span class="cov8" title="1">{
                        if checked </span><span class="cov8" title="1">{
                                item.Checkbox.Disable()
                        }</span> else<span class="cov8" title="1"> {
                                item.Checkbox.Enable()
                        }</span>
                }
        }
        <span class="cov8" title="1">widgetAll := widget.NewCheck("Unlock all Research", changedUnlockAll)
        g.UnlockAllResearch = widgetAll

        return newBorder(container.NewVBox(widgetAll, researchGrid))</span>
}

type OtherOptions struct {
        StarterWorker struct {
                Value binding.Int
                Entry *widget.Entry
        }
        HabitatWorkers *widget.Check
        HabitatStorage *widget.Check
        FactoryStorage *widget.Check
        UpgradesOnly   *widget.Check
}

func (g *GUI) makeOptionsBox() fyne.CanvasObject <span class="cov8" title="1">{
        g.OtherOptions = OtherOptions{
                HabitatWorkers: widget.NewCheck("Fill all habitats with workers", nil),
                HabitatStorage: widget.NewCheck("Fill the storage of all habitats", nil),
                FactoryStorage: widget.NewCheck("Fill the storage of all factories", nil),
                UpgradesOnly:   widget.NewCheck("Fill only upgrades factories", nil),
        }

        g.OtherOptions.FactoryStorage.OnChanged = func(b bool) </span><span class="cov0" title="0">{
                if b </span><span class="cov0" title="0">{
                        g.OtherOptions.UpgradesOnly.Checked = b
                        g.OtherOptions.UpgradesOnly.Disable()
                }</span> else<span class="cov0" title="0"> {
                        g.OtherOptions.UpgradesOnly.Enable()
                }</span>
                <span class="cov0" title="0">g.OtherOptions.UpgradesOnly.Refresh()</span>
        }

        <span class="cov8" title="1">g.OtherOptions.StarterWorker.Value = binding.NewInt()
        g.OtherOptions.StarterWorker.Entry = widget.NewEntryWithData(binding.IntToString(g.OtherOptions.StarterWorker.Value))
        size := g.OtherOptions.StarterWorker.Entry.MinSize()
        size.Width = ENTRY_WIDTH
        wrappedStarterWorkerEntry := container.NewGridWrap(size, g.OtherOptions.StarterWorker.Entry)
        starterWorkerLabel := canvas.NewText("Increase starter worker count: ", TEXT_COLOR)
        starterWorkerBox := container.NewHBox(starterWorkerLabel, wrappedStarterWorkerEntry)

        checkboxes := container.NewGridWithColumns(4, g.OtherOptions.HabitatWorkers, g.OtherOptions.HabitatStorage, g.OtherOptions.FactoryStorage, g.OtherOptions.UpgradesOnly)

        return newBorder(container.NewVBox(starterWorkerBox, checkboxes))</span>
}

func (g *GUI) makeActionButtons() fyne.CanvasObject <span class="cov8" title="1">{
        resetWarning := func() </span><span class="cov0" title="0">{
                dialog.NewConfirm("Warning", "This will reload all values from the save", func(b bool) </span><span class="cov0" title="0">{
                        if b </span><span class="cov0" title="0">{
                                g.ReloadFromSave()
                        }</span>
                }, g.Main).Show()
        }
        <span class="cov8" title="1">reset := widget.NewButton("Reset", resetWarning)
        reset.Disable()
        saveFile := widget.NewButton("Save", g.writeSavegame)
        saveFile.Disable()

        g.ActionButtons = []*widget.Button{reset, saveFile}

        return container.NewPadded(container.NewCenter(container.NewHBox(reset, saveFile)))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package gui

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "github.com/heathcliff26/infraspace-savegame-editor/pkg/version"
)

func getVersionContent() fyne.CanvasObject <span class="cov0" title="0">{
        v := version.Version()

        r1 := make([]fyne.CanvasObject, 4)
        r2 := make([]fyne.CanvasObject, 4)
        r1[0] = canvas.NewText("Version:", TEXT_COLOR)
        r2[0] = canvas.NewText(v.Version, TEXT_COLOR)
        r1[1] = canvas.NewText("Commit:", TEXT_COLOR)
        r2[1] = canvas.NewText(v.Commit, TEXT_COLOR)
        r1[2] = canvas.NewText("Go:", TEXT_COLOR)
        r2[2] = canvas.NewText(v.Go, TEXT_COLOR)
        r1[3] = canvas.NewText("InfraSpace:", TEXT_COLOR)
        r2[3] = canvas.NewText(v.GameVersion, TEXT_COLOR)

        row1 := container.NewVBox(r1...)
        row2 := container.NewVBox(r2...)

        return container.NewPadded(container.NewHBox(row1, row2))
}</span>

func makeBorderStrip() fyne.CanvasObject <span class="cov8" title="1">{
        rec := canvas.NewRectangle(BORDER_COLOR)
        rec.SetMinSize(fyne.NewSize(BORDER_SIZE, BORDER_SIZE))
        return rec
}</span>

func newBorder(content ...fyne.CanvasObject) fyne.CanvasObject <span class="cov8" title="1">{
        top := makeBorderStrip()
        left := makeBorderStrip()
        bottom := makeBorderStrip()
        right := makeBorderStrip()
        border := container.NewBorder(top, bottom, left, right, content...)
        return container.NewPadded(border)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package save

import "fmt"

type ErrMissingKey struct {
        Map, Key string
}

func NewErrMissingKey(m, key string) error <span class="cov0" title="0">{
        return &amp;ErrMissingKey{m, key}
}</span>

func (e *ErrMissingKey) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("The map \"%s\" has no key \"%s\"", e.Map, e.Key)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package save

import (
        "encoding/json"
)

type SaveData struct {
        MapSeed                    int64               `json:"mapSeed"`
        MapGenVersion              int64               `json:"mapGenVersion"`
        NextID                     int64               `json:"nextID"`
        SimulationFrame            int64               `json:"simulationFrame"`
        TotalGameTime              float64             `json:"totalGameTime"`
        TotalPlayTime              float64             `json:"totalPlayTime"`
        SaveFixGracePeriodActive   bool                `json:"saveFixGracePeriodActive"`
        WorldSettings              json.RawMessage     `json:"worldSettings"`
        Buildings                  []Building          `json:"buildings"`
        BuildingConnectors         json.RawMessage     `json:"buildingConnectors"`
        BuildingGroups             json.RawMessage     `json:"buildingGroups"`
        NetEdges                   json.RawMessage     `json:"netEdges"`
        NetNodes                   json.RawMessage     `json:"netNodes"`
        Cars                       json.RawMessage     `json:"cars"`
        Market                     Market              `json:"market"`
        Resources                  map[string]int64    `json:"resources"`
        GoalManager                json.RawMessage     `json:"goalManager"`
        ResearchManager            ResearchManager     `json:"researchManager"`
        PopulationManager          json.RawMessage     `json:"populationManager"`
        Statistics                 json.RawMessage     `json:"statistics"`
        Camera                     json.RawMessage     `json:"camera"`
        DistrictManager            json.RawMessage     `json:"districtManager"`
        TrainLineManager           json.RawMessage     `json:"trainLineManager"`
        Trains                     json.RawMessage     `json:"trains"`
        CarCarriers                json.RawMessage     `json:"carCarriers"`
        Spaceship                  json.RawMessage     `json:"spaceship"`
        PipeComponentManager       json.RawMessage     `json:"pipeComponentManager"`
        ScriptMods                 json.RawMessage     `json:"scriptMods"`
        NewWorldPersistent         NewWorldPersistent  `json:"newWorldPersistent"`
        EnvironmentObjects         []EnvironmentObject `json:"environmentObjects"` // Very Big Object ca. 8k lines
        TerraformingProgressString json.RawMessage     `json:"terraformingProgressString"`
        AchievementsManager        AchievementsManager `json:"achievementsManager"`
        TrailerModule              json.RawMessage     `json:"trailerModule"`
        StoryMessagesModule        json.RawMessage     `json:"storyMessagesModule"`
        Roads                      json.RawMessage     `json:"roads"`
        Intersections              json.RawMessage     `json:"intersections"`
}

type Building struct {
        BuildingName            string          `json:"buildingName"`
        CustomName              json.RawMessage `json:"customName"`
        Road                    int64           `json:"road"`
        Pipes                   json.RawMessage `json:"pipes"`
        ID                      int
        Position                json.RawMessage   `json:"position"`
        Rotation                float64           `json:"rotation"`
        ConsumerProducer        *ConsumerProducer `json:"consumerProducer"`
        MissingResourceDuration float64           `json:"missingResourceDuration"`
        Upgrades                json.RawMessage   `json:"upgrades"`
        IntegratedNetEdges      json.RawMessage   `json:"integratedNetEdges"`
        TextModule              json.RawMessage   `json:"textModule"`
        StationModule           json.RawMessage   `json:"stationModule"`
}

type ConsumerProducer struct {
        ProductionLogic       interface{} `json:"productionLogic"`
        IncomingStorage       []int64     `json:"incomingStorage"`
        OutgoingStorage       []int64     `json:"outgoingStorage"`
        RequestStatusDirty    bool        `json:"requestStatusDirty"`
        LastStepPowerProduced float64     `json:"lastStepPowerProduced"`
        LastStepPowerNeeded   float64     `json:"lastStepPowerNeeded"`

        Type BuildingType `json:"-"`
}

type BuildingType int

type FactoryProductionLogic struct {
        Type                 string          `json:"$type"`
        ProductionDefinition json.RawMessage `json:"productionDefinition"`
        LogicOverride        json.RawMessage `json:"logicOverride"`
        TerraformRadius      float64         `json:"terraformRadius"`
        TerraformType        json.RawMessage `json:"terraformType"`
        ProductionTimeStep   int64           `json:"productionTimeStep"`
}

type HabitatProductionLogic struct {
        Type                    string             `json:"$type"`
        Storage                 map[string]float64 `json:"storage"`
        MaxInhabitants          int64              `json:"maxInhabitants"`
        HabitatLevel            int64              `json:"habitatLevel"`
        Upgrade                 string             `json:"upgrade"`
        Downgrade               json.RawMessage    `json:"downgrade"`
        PowerNeededForTenPeople float64            `json:"powerNeededForTenPeople"`
        TargetInhabitants       float64            `json:"targetInhabitants"`
        UpgradeCountdown        float64            `json:"upgradeCountdown"`
        DowngradeCountdown      float64            `json:"downgradeCountdown"`
        Workers                 []Worker           `json:"workers"`
}

type Market struct {
        StarterWorkers     []Worker        `json:"starterWorkers"`
        ResourcePriorities json.RawMessage `json:"resourcePriorities"`
}

type Worker struct {
        Home int64 `json:"_home"`
        ID   int64
}

type ResearchManager struct {
        ResearchProgress map[string]int64 `json:"researchProgress"`
        CurrentResearch  json.RawMessage  `json:"currentResearch"`
        ResearchQueue    []string         `json:"researchQueue"`
}

type NewWorldPersistent struct {
        HeightData string          `json:"heightData"`
        AlphaData  []string        `json:"alphaData"`
        DetailData []string        `json:"detailData"`
        BiomesData json.RawMessage `json:"biomesData"`
}

type EnvironmentObject struct {
        ID                  int64
        ObjectName          string  `json:"objectName"`
        Health              float64 `json:"health"`
        TransformCompressed string  `json:"transformCompressed"`
}

type AchievementsManager struct {
        UnlockabilityStatus           UnlockabilityStatus `json:"unlockabilityStatus"`
        SerializedAchievementTrackers json.RawMessage     `json:"serializedAchievementTrackers"`
}

type UnlockabilityStatus struct {
        DisabledDueToMods                             bool `json:"disabledDueToMods"`
        DisabledDueToCreativeSettings                 bool `json:"disabledDueToCreativeSettings"`
        DisabledDueToSettingsModification             bool `json:"disabledDueToSettingsModification"`
        DisabledDueToCheats                           bool `json:"disabledDueToCheats"`
        DisabledDueToModsBackingField                 bool `json:"&lt;disabledDueToMods&gt;k__BackingField"`
        DisabledDueToCreativeSettingsBackingField     bool `json:"&lt;disabledDueToCreativeSettings&gt;k__BackingField"`
        DisabledDueToSettingsModificationBackingField bool `json:"&lt;disabledDueToSettingsModification&gt;k__BackingField"`
        DisabledDueToCheatsBackingField               bool `json:"&lt;disabledDueToCheats&gt;k__BackingField"`
}

func (c *ConsumerProducer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var v map[string]json.RawMessage
        err := json.Unmarshal(data, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(v["incomingStorage"], &amp;c.IncomingStorage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(v["outgoingStorage"], &amp;c.OutgoingStorage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(v["requestStatusDirty"], &amp;c.RequestStatusDirty)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(v["lastStepPowerProduced"], &amp;c.LastStepPowerProduced)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(v["lastStepPowerNeeded"], &amp;c.LastStepPowerNeeded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var tmp struct {
                Type string `json:"$type"`
        }
        err = json.Unmarshal(v["productionLogic"], &amp;tmp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch tmp.Type </span>{
        case "FactoryProductionLogic, old":<span class="cov8" title="1">
                c.Type = TYPE_FACTORY
                var fProd FactoryProductionLogic
                err = json.Unmarshal(v["productionLogic"], &amp;fProd)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.ProductionLogic = fProd</span>
        case "Habitat, old":<span class="cov8" title="1">
                c.Type = TYPE_HABITAT
                var hProd HabitatProductionLogic
                err = json.Unmarshal(v["productionLogic"], &amp;hProd)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.ProductionLogic = hProd</span>
        case "StorehouseProductionLogic, old":<span class="cov8" title="1">
                c.Type = TYPE_STOREHOUSE</span>
        case "ResearchProductionLogic, old":<span class="cov8" title="1">
                c.Type = TYPE_RESEARCH</span>
        default:<span class="cov8" title="1">
                c.Type = TYPE_UNKNOWN</span>
        }
        <span class="cov8" title="1">if c.Type &gt; 1 </span><span class="cov8" title="1">{
                var raw json.RawMessage
                err = json.Unmarshal(v["productionLogic"], &amp;raw)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.ProductionLogic = raw</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package save

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "reflect"
)

type Savegame struct {
        Changed bool

        path   string
        prefix string
        data   *SaveData
}

// Load the savegame from the path
func LoadSavegame(path string) (*Savegame, error) <span class="cov0" title="0">{
        prefix, buf, err := readSaveFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var data SaveData
        err = json.Unmarshal(buf, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Savegame{
                Changed: false,
                path:    path,
                prefix:  prefix,
                data:    &amp;data,
        }, nil</span>
}

// Save the savegame to the Path
func (s *Savegame) Save() error <span class="cov0" title="0">{
        data, err := marshalJSON(s.Data())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fullSave := s.prefix + data
        err = os.WriteFile(s.Path(), []byte(fullSave), 0644)
        return err</span>
}

// Create a backup of the save file, returns the path of the backup
func (s *Savegame) Backup() (string, error) <span class="cov0" title="0">{
        dst := s.Path() + ".backup"
        i := 0
        _, err := os.Stat(dst)
        for !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                i++
                dst = s.Path() + ".backup_" + fmt.Sprint(i)
                _, err = os.Stat(dst)
        }</span>

        <span class="cov0" title="0">input, err := os.ReadFile(s.Path())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(dst, input, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return dst, nil</span>
}

func (s *Savegame) Path() string <span class="cov0" title="0">{
        return s.path
}</span>

func (s *Savegame) Prefix() string <span class="cov0" title="0">{
        return s.prefix
}</span>

func (s *Savegame) Data() *SaveData <span class="cov0" title="0">{
        return s.data
}</span>

// Get a resource by name
func (s *Savegame) GetResource(key string) (int, bool) <span class="cov0" title="0">{
        value, ok := s.Data().Resources[key]
        return int(value / RESOURCE_FACTOR), ok
}</span>

// Get unlocked research
func (s *Savegame) GetUnlockedResearch() []string <span class="cov0" title="0">{
        res := make([]string, 0, len(maxResearchProgress))
        for k, v := range maxResearchProgress </span><span class="cov0" title="0">{
                if s.Data().ResearchManager.ResearchProgress[k] == v </span><span class="cov0" title="0">{
                        res = append(res, k)
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

// Get the current number of starter workers
func (s *Savegame) GetStarterWorkerCount() int <span class="cov0" title="0">{
        return len(s.Data().Market.StarterWorkers)
}</span>

// Unlock research by name
func (s *Savegame) UnlockResearch(name string) <span class="cov0" title="0">{
        if s.Data().ResearchManager.ResearchProgress[name] != maxResearchProgress[name] </span><span class="cov0" title="0">{
                s.Data().ResearchManager.ResearchProgress[name] = maxResearchProgress[name]
                s.Changed = true
        }</span>
}

// Lock Research by name, if currently unlocked
func (s *Savegame) LockResearch(name string) <span class="cov0" title="0">{
        if s.Data().ResearchManager.ResearchProgress[name] == maxResearchProgress[name] </span><span class="cov0" title="0">{
                s.Data().ResearchManager.ResearchProgress[name] = 0
                s.Changed = true
        }</span>
}

// Unlocks all research
func (s *Savegame) UnlockAllResearch() <span class="cov0" title="0">{
        for name := range s.Data().ResearchManager.ResearchProgress </span><span class="cov0" title="0">{
                s.UnlockResearch(name)
        }</span>
}

// Increase the starter workers to the given count, return number of added workers
func (s *Savegame) AddStarterWorkers(count int) int64 <span class="cov0" title="0">{
        var diff int64
        diff, s.Data().Market.StarterWorkers = s.addWorkers(count, s.Data().Market.StarterWorkers)

        if diff &gt; 0 </span><span class="cov0" title="0">{
                s.Changed = true
        }</span>
        <span class="cov0" title="0">return diff</span>
}

// Adds workes to the given array until it's length matches count
func (s *Savegame) addWorkers(count int, workers []Worker) (int64, []Worker) <span class="cov0" title="0">{
        oldNextID := s.Data().NextID
        for len(workers) &lt; count </span><span class="cov0" title="0">{
                newWorker := Worker{
                        Home: 0,
                        ID:   s.Data().NextID,
                }
                s.Data().NextID++
                workers = append(workers, newWorker)
        }</span>
        <span class="cov0" title="0">return (s.Data().NextID - oldNextID), workers</span>
}

// Set the given resource
func (s *Savegame) SetResource(key string, value int) error <span class="cov0" title="0">{
        if _, ok := s.Data().Resources[key]; ok </span><span class="cov0" title="0">{
                s.Data().Resources[key] = int64(value) * RESOURCE_FACTOR
                s.Changed = true
                return nil
        }</span> else<span class="cov0" title="0"> {
                return NewErrMissingKey("resources", key)
        }</span>
}

type EditBuildingsOptions struct {
        HabitatWorkers bool
        HabitatStorage bool
        FactoryStorage bool
        UpgradesOnly   bool
}

// Edit the buildings with the given configuration
func (s *Savegame) EditBuildings(opt EditBuildingsOptions) <span class="cov0" title="0">{
        if !reflect.DeepEqual(opt, EditBuildingsOptions{}) </span><span class="cov0" title="0">{
                buildings := s.Data().Buildings
                for i := 0; i &lt; len(buildings); i++ </span><span class="cov0" title="0">{
                        if buildings[i].ConsumerProducer != nil &amp;&amp; buildings[i].ConsumerProducer.Type == TYPE_HABITAT </span><span class="cov0" title="0">{
                                if opt.HabitatStorage </span><span class="cov0" title="0">{
                                        buildings[i] = maxHabitatStorage(buildings[i])
                                }</span>
                                <span class="cov0" title="0">if opt.HabitatWorkers </span><span class="cov0" title="0">{
                                        buildings[i] = s.fillHabitatWorkers(buildings[i])
                                }</span>
                        }

                        <span class="cov0" title="0">if buildings[i].ConsumerProducer != nil &amp;&amp; buildings[i].ConsumerProducer.Type == TYPE_FACTORY </span><span class="cov0" title="0">{
                                if opt.FactoryStorage </span><span class="cov0" title="0">{
                                        buildings[i] = maxFactoryStorage(buildings[i])
                                }</span> else<span class="cov0" title="0"> if opt.UpgradesOnly &amp;&amp; (buildings[i].BuildingName == "industrialRobotFactory" || buildings[i].BuildingName == "highTechWorkshop") </span><span class="cov0" title="0">{
                                        buildings[i] = maxFactoryStorage(buildings[i])
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.Changed = true</span>
        }
}

func (s *Savegame) fillHabitatWorkers(b Building) Building <span class="cov0" title="0">{
        prodLogic := b.ConsumerProducer.ProductionLogic.(HabitatProductionLogic)
        count := int(prodLogic.MaxInhabitants)
        _, prodLogic.Workers = s.addWorkers(count, prodLogic.Workers)
        b.ConsumerProducer.ProductionLogic = prodLogic
        return b
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package save

import (
        "bytes"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"
)

func ResourceNames() []string <span class="cov8" title="1">{
        list := make([]string, len(resourceNames))
        copy(list, resourceNames)
        return list
}</span>

func ResearchNames() []string <span class="cov8" title="1">{
        list := make([]string, len(researchNames))
        copy(list, researchNames)
        return list
}</span>

func DefaultSaveLocation() (string, error) <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var path string
        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                path = saveFolderWindows(home)</span>
        case "linux":<span class="cov8" title="1">
                path = filepath.Join(home, "snap/steam/common/.local/share/Steam/steamapps/compatdata/1511460/pfx/drive_c/users/steamuser/")
                path = saveFolderWindows(path)</span>
        }
        <span class="cov8" title="1">if _, err := os.Stat(path); path != "" &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return path, nil
        }</span> else<span class="cov8" title="1"> {
                return home, nil
        }</span>
}

func saveFolderWindows(root string) string <span class="cov8" title="1">{
        return filepath.Join(root, "AppData", "LocalLow", "Dionic Software", "InfraSpace", "saves")
}</span>

func readSaveFile(path string) (string, []byte, error) <span class="cov8" title="1">{
        buf, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>
        <span class="cov8" title="1">fullSave := string(buf)
        i := strings.Index(fullSave, "{")
        if i &lt; 0 </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("could not find start of json-body")
        }</span>
        <span class="cov8" title="1">return fullSave[:i], []byte(fullSave[i:]), nil</span>
}

func maxFactoryStorage(building Building) Building <span class="cov8" title="1">{
        if building.ConsumerProducer == nil </span><span class="cov8" title="1">{
                return building
        }</span>
        <span class="cov8" title="1">building.ConsumerProducer.IncomingStorage = maxStorage(building.ConsumerProducer.IncomingStorage)
        building.ConsumerProducer.OutgoingStorage = maxStorage(building.ConsumerProducer.OutgoingStorage)
        return building</span>
}

func maxStorage(storage []int64) []int64 <span class="cov8" title="1">{
        for i := range storage </span><span class="cov8" title="1">{
                storage[i] = BUILDING_MAX_STORAGE
        }</span>
        <span class="cov8" title="1">return storage</span>
}

func maxHabitatStorage(building Building) Building <span class="cov8" title="1">{
        if building.ConsumerProducer == nil || building.ConsumerProducer.Type != TYPE_HABITAT </span><span class="cov8" title="1">{
                return building
        }</span>
        <span class="cov8" title="1">for key := range building.ConsumerProducer.ProductionLogic.(HabitatProductionLogic).Storage </span><span class="cov8" title="1">{
                building.ConsumerProducer.ProductionLogic.(HabitatProductionLogic).Storage[key] = BUILDING_MAX_STORAGE
        }</span>
        <span class="cov8" title="1">return building</span>
}

func marshalJSON(v any) (string, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        enc := json.NewEncoder(buf)

        enc.SetEscapeHTML(false)
        enc.SetIndent("", "  ")

        err := enc.Encode(v)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
