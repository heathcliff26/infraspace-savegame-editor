
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>save: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/infraspace-savegame-editor/pkg/save/errors.go (0.0%)</option>
				
				<option value="file1">github.com/heathcliff26/infraspace-savegame-editor/pkg/save/json.go (76.1%)</option>
				
				<option value="file2">github.com/heathcliff26/infraspace-savegame-editor/pkg/save/save.go (0.0%)</option>
				
				<option value="file3">github.com/heathcliff26/infraspace-savegame-editor/pkg/save/utils.go (56.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package save

import "fmt"

type ErrMissingKey struct {
        Map, Key string
}

func NewErrMissingKey(m, key string) error <span class="cov0" title="0">{
        return &amp;ErrMissingKey{m, key}
}</span>

func (e *ErrMissingKey) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("The map \"%s\" has no key \"%s\"", e.Map, e.Key)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package save

import (
        "encoding/json"
)

type SaveData struct {
        MapSeed                    int64               `json:"mapSeed"`
        MapGenVersion              int64               `json:"mapGenVersion"`
        NextID                     int64               `json:"nextID"`
        SimulationFrame            int64               `json:"simulationFrame"`
        TotalGameTime              float64             `json:"totalGameTime"`
        TotalPlayTime              float64             `json:"totalPlayTime"`
        SaveFixGracePeriodActive   bool                `json:"saveFixGracePeriodActive"`
        WorldSettings              json.RawMessage     `json:"worldSettings"`
        Buildings                  []Building          `json:"buildings"`
        BuildingConnectors         json.RawMessage     `json:"buildingConnectors"`
        BuildingGroups             json.RawMessage     `json:"buildingGroups"`
        NetEdges                   json.RawMessage     `json:"netEdges"`
        NetNodes                   json.RawMessage     `json:"netNodes"`
        Cars                       json.RawMessage     `json:"cars"`
        Market                     Market              `json:"market"`
        Resources                  map[string]int64    `json:"resources"`
        GoalManager                json.RawMessage     `json:"goalManager"`
        ResearchManager            ResearchManager     `json:"researchManager"`
        PopulationManager          json.RawMessage     `json:"populationManager"`
        Statistics                 json.RawMessage     `json:"statistics"`
        Camera                     json.RawMessage     `json:"camera"`
        DistrictManager            json.RawMessage     `json:"districtManager"`
        TrainLineManager           json.RawMessage     `json:"trainLineManager"`
        Trains                     json.RawMessage     `json:"trains"`
        CarCarriers                json.RawMessage     `json:"carCarriers"`
        Spaceship                  json.RawMessage     `json:"spaceship"`
        PipeComponentManager       json.RawMessage     `json:"pipeComponentManager"`
        ScriptMods                 json.RawMessage     `json:"scriptMods"`
        NewWorldPersistent         NewWorldPersistent  `json:"newWorldPersistent"`
        EnvironmentObjects         []EnvironmentObject `json:"environmentObjects"` // Very Big Object ca. 8k lines
        TerraformingProgressString json.RawMessage     `json:"terraformingProgressString"`
        AchievementsManager        AchievementsManager `json:"achievementsManager"`
        TrailerModule              json.RawMessage     `json:"trailerModule"`
        StoryMessagesModule        json.RawMessage     `json:"storyMessagesModule"`
        Roads                      json.RawMessage     `json:"roads"`
        Intersections              json.RawMessage     `json:"intersections"`
}

type Building struct {
        BuildingName            string          `json:"buildingName"`
        CustomName              json.RawMessage `json:"customName"`
        Road                    int64           `json:"road"`
        Pipes                   json.RawMessage `json:"pipes"`
        ID                      int
        Position                json.RawMessage   `json:"position"`
        Rotation                float64           `json:"rotation"`
        ConsumerProducer        *ConsumerProducer `json:"consumerProducer"`
        MissingResourceDuration float64           `json:"missingResourceDuration"`
        Upgrades                json.RawMessage   `json:"upgrades"`
        IntegratedNetEdges      json.RawMessage   `json:"integratedNetEdges"`
        TextModule              json.RawMessage   `json:"textModule"`
        StationModule           json.RawMessage   `json:"stationModule"`
}

type ConsumerProducer struct {
        ProductionLogic       interface{} `json:"productionLogic"`
        IncomingStorage       []int64     `json:"incomingStorage"`
        OutgoingStorage       []int64     `json:"outgoingStorage"`
        RequestStatusDirty    bool        `json:"requestStatusDirty"`
        LastStepPowerProduced float64     `json:"lastStepPowerProduced"`
        LastStepPowerNeeded   float64     `json:"lastStepPowerNeeded"`

        Type BuildingType `json:"-"`
}

type BuildingType int

type FactoryProductionLogic struct {
        Type                 string          `json:"$type"`
        ProductionDefinition json.RawMessage `json:"productionDefinition"`
        LogicOverride        json.RawMessage `json:"logicOverride"`
        TerraformRadius      float64         `json:"terraformRadius"`
        TerraformType        json.RawMessage `json:"terraformType"`
        ProductionTimeStep   int64           `json:"productionTimeStep"`
}

type HabitatProductionLogic struct {
        Type                    string             `json:"$type"`
        Storage                 map[string]float64 `json:"storage"`
        MaxInhabitants          int64              `json:"maxInhabitants"`
        HabitatLevel            int64              `json:"habitatLevel"`
        Upgrade                 string             `json:"upgrade"`
        Downgrade               json.RawMessage    `json:"downgrade"`
        PowerNeededForTenPeople float64            `json:"powerNeededForTenPeople"`
        TargetInhabitants       float64            `json:"targetInhabitants"`
        UpgradeCountdown        float64            `json:"upgradeCountdown"`
        DowngradeCountdown      float64            `json:"downgradeCountdown"`
        Workers                 []Worker           `json:"workers"`
}

type Market struct {
        StarterWorkers     []Worker        `json:"starterWorkers"`
        ResourcePriorities json.RawMessage `json:"resourcePriorities"`
}

type Worker struct {
        Home int64 `json:"_home"`
        ID   int64
}

type ResearchManager struct {
        ResearchProgress map[string]int64 `json:"researchProgress"`
        CurrentResearch  json.RawMessage  `json:"currentResearch"`
        ResearchQueue    []string         `json:"researchQueue"`
}

type NewWorldPersistent struct {
        HeightData string          `json:"heightData"`
        AlphaData  []string        `json:"alphaData"`
        DetailData []string        `json:"detailData"`
        BiomesData json.RawMessage `json:"biomesData"`
}

type EnvironmentObject struct {
        ID                  int64
        ObjectName          string  `json:"objectName"`
        Health              float64 `json:"health"`
        TransformCompressed string  `json:"transformCompressed"`
}

type AchievementsManager struct {
        UnlockabilityStatus           UnlockabilityStatus `json:"unlockabilityStatus"`
        SerializedAchievementTrackers json.RawMessage     `json:"serializedAchievementTrackers"`
}

type UnlockabilityStatus struct {
        DisabledDueToMods                             bool `json:"disabledDueToMods"`
        DisabledDueToCreativeSettings                 bool `json:"disabledDueToCreativeSettings"`
        DisabledDueToSettingsModification             bool `json:"disabledDueToSettingsModification"`
        DisabledDueToCheats                           bool `json:"disabledDueToCheats"`
        DisabledDueToModsBackingField                 bool `json:"&lt;disabledDueToMods&gt;k__BackingField"`
        DisabledDueToCreativeSettingsBackingField     bool `json:"&lt;disabledDueToCreativeSettings&gt;k__BackingField"`
        DisabledDueToSettingsModificationBackingField bool `json:"&lt;disabledDueToSettingsModification&gt;k__BackingField"`
        DisabledDueToCheatsBackingField               bool `json:"&lt;disabledDueToCheats&gt;k__BackingField"`
}

func (c *ConsumerProducer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var v map[string]json.RawMessage
        err := json.Unmarshal(data, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(v["incomingStorage"], &amp;c.IncomingStorage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(v["outgoingStorage"], &amp;c.OutgoingStorage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(v["requestStatusDirty"], &amp;c.RequestStatusDirty)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(v["lastStepPowerProduced"], &amp;c.LastStepPowerProduced)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(v["lastStepPowerNeeded"], &amp;c.LastStepPowerNeeded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var tmp struct {
                Type string `json:"$type"`
        }
        err = json.Unmarshal(v["productionLogic"], &amp;tmp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch tmp.Type </span>{
        case "FactoryProductionLogic, old":<span class="cov8" title="1">
                c.Type = TYPE_FACTORY
                var fProd FactoryProductionLogic
                err = json.Unmarshal(v["productionLogic"], &amp;fProd)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.ProductionLogic = fProd</span>
        case "Habitat, old":<span class="cov8" title="1">
                c.Type = TYPE_HABITAT
                var hProd HabitatProductionLogic
                err = json.Unmarshal(v["productionLogic"], &amp;hProd)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.ProductionLogic = hProd</span>
        case "StorehouseProductionLogic, old":<span class="cov8" title="1">
                c.Type = TYPE_STOREHOUSE</span>
        case "ResearchProductionLogic, old":<span class="cov8" title="1">
                c.Type = TYPE_RESEARCH</span>
        default:<span class="cov0" title="0">
                c.Type = TYPE_UNKNOWN</span>
        }
        <span class="cov8" title="1">if c.Type &gt; 1 </span><span class="cov8" title="1">{
                var raw json.RawMessage
                err = json.Unmarshal(v["productionLogic"], &amp;raw)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.ProductionLogic = raw</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package save

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
)

type Savegame struct {
        Changed bool

        path   string
        prefix string
        data   *SaveData
}

// Load the savegame from the path
func LoadSavegame(path string) (*Savegame, error) <span class="cov0" title="0">{
        prefix, buf, err := readSaveFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var data SaveData
        err = json.Unmarshal(buf, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Savegame{
                Changed: false,
                path:    path,
                prefix:  prefix,
                data:    &amp;data,
        }, nil</span>
}

// Save the savegame to the Path
func (s *Savegame) Save() error <span class="cov0" title="0">{
        data, err := marshalJSON(s.Data())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fullSave := s.prefix + data
        err = os.WriteFile(s.Path(), []byte(fullSave), 0644)
        return err</span>
}

// Create a backup of the save file, returns the path of the backup
func (s *Savegame) Backup() (string, error) <span class="cov0" title="0">{
        dst := s.Path() + ".backup"
        i := 0
        _, err := os.Stat(dst)
        for !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                i++
                dst = s.Path() + ".backup_" + fmt.Sprint(i)
                _, err = os.Stat(dst)
        }</span>

        <span class="cov0" title="0">input, err := os.ReadFile(s.Path())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(dst, input, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return dst, nil</span>
}

func (s *Savegame) Path() string <span class="cov0" title="0">{
        return s.path
}</span>

func (s *Savegame) Prefix() string <span class="cov0" title="0">{
        return s.prefix
}</span>

func (s *Savegame) Data() *SaveData <span class="cov0" title="0">{
        return s.data
}</span>

// Get a resource by name
func (s *Savegame) GetResource(key string) (int, bool) <span class="cov0" title="0">{
        value, ok := s.Data().Resources[key]
        return int(value / RESOURCE_FACTOR), ok
}</span>

// Get unlocked research
func (s *Savegame) GetUnlockedResearch() []string <span class="cov0" title="0">{
        res := make([]string, 0, len(maxResearchProgress))
        for k, v := range maxResearchProgress </span><span class="cov0" title="0">{
                if s.Data().ResearchManager.ResearchProgress[k] == v </span><span class="cov0" title="0">{
                        res = append(res, k)
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

// Get the current number of starter workers
func (s *Savegame) GetStarterWorkerCount() int <span class="cov0" title="0">{
        return len(s.Data().Market.StarterWorkers)
}</span>

// Unlock research by name
func (s *Savegame) UnlockResearch(name string) <span class="cov0" title="0">{
        if s.Data().ResearchManager.ResearchProgress[name] != maxResearchProgress[name] </span><span class="cov0" title="0">{
                s.Data().ResearchManager.ResearchProgress[name] = maxResearchProgress[name]
                s.Changed = true
        }</span>
}

// Lock Research by name, if currently unlocked
func (s *Savegame) LockResearch(name string) <span class="cov0" title="0">{
        if s.Data().ResearchManager.ResearchProgress[name] == maxResearchProgress[name] </span><span class="cov0" title="0">{
                s.Data().ResearchManager.ResearchProgress[name] = 0
                s.Changed = true
        }</span>
}

// Unlocks all research
func (s *Savegame) UnlockAllResearch() <span class="cov0" title="0">{
        for name := range s.Data().ResearchManager.ResearchProgress </span><span class="cov0" title="0">{
                s.UnlockResearch(name)
        }</span>
}

// Increase the starter workers to the given count, return number of added workers
func (s *Savegame) AddStarterWorkers(count int) int64 <span class="cov0" title="0">{
        oldNextID := s.Data().NextID
        for s.GetStarterWorkerCount() &lt; count </span><span class="cov0" title="0">{
                newWorker := Worker{
                        Home: 0,
                        ID:   s.Data().NextID,
                }
                s.Data().NextID++
                s.Data().Market.StarterWorkers = append(s.Data().Market.StarterWorkers, newWorker)
        }</span>

        <span class="cov0" title="0">diff := (s.Data().NextID - oldNextID)
        if diff &gt; 0 </span><span class="cov0" title="0">{
                s.Changed = true
        }</span>
        <span class="cov0" title="0">return diff</span>
}

// Set the given resource
func (s *Savegame) SetResource(key string, value int) error <span class="cov0" title="0">{
        if _, ok := s.Data().Resources[key]; ok </span><span class="cov0" title="0">{
                s.Data().Resources[key] = int64(value) * RESOURCE_FACTOR
                s.Changed = true
                return nil
        }</span> else<span class="cov0" title="0"> {
                return NewErrMissingKey("resources", key)
        }</span>
}

type EditBuildingsOptions struct {
        HabitatWorkers   bool
        HabitatStorage   bool
        IndustrialRobots bool
        FactoryStorage   bool
}

// Edit the buildings with the given configuration
func (s *Savegame) EditBuildings(opt EditBuildingsOptions) <span class="cov0" title="0">{
        if opt.HabitatWorkers </span><span class="cov0" title="0">{
                fmt.Println("Noop HabitatWorkers")
        }</span>
        <span class="cov0" title="0">if opt.IndustrialRobots </span><span class="cov0" title="0">{
                fmt.Println("Noop IndustrialRobots")
        }</span>
        <span class="cov0" title="0">buildings := s.Data().Buildings
        for i := 0; i &lt; len(buildings); i++ </span><span class="cov0" title="0">{
                if buildings[i].ConsumerProducer != nil &amp;&amp; buildings[i].ConsumerProducer.Type == TYPE_HABITAT </span><span class="cov0" title="0">{
                        if opt.HabitatStorage </span><span class="cov0" title="0">{
                                buildings[i] = maxBuildingStorage(buildings[i])
                        }</span>
                }

                <span class="cov0" title="0">if opt.FactoryStorage &amp;&amp; buildings[i].ConsumerProducer != nil &amp;&amp; buildings[i].ConsumerProducer.Type == TYPE_FACTORY </span><span class="cov0" title="0">{
                        buildings[i] = maxBuildingStorage(buildings[i])
                }</span>
        }
        <span class="cov0" title="0">s.Changed = true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package save

import (
        "bytes"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"
)

func ResourceNames() []string <span class="cov0" title="0">{
        list := make([]string, len(researchNames))
        copy(list, resourceNames)
        return list
}</span>

func ResearchNames() []string <span class="cov0" title="0">{
        list := make([]string, len(researchNames))
        copy(list, researchNames)
        return list
}</span>

func DefaultSaveLocation() (string, error) <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var path string
        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                path = saveFolderWindows(home)</span>
        case "linux":<span class="cov8" title="1">
                path = filepath.Join(home, "snap/steam/common/.local/share/Steam/steamapps/compatdata/1511460/pfx/drive_c/users/steamuser/")
                path = saveFolderWindows(path)</span>
        }
        <span class="cov8" title="1">if _, err := os.Stat(path); path != "" &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return path, nil
        }</span> else<span class="cov8" title="1"> {
                return home, nil
        }</span>
}

func saveFolderWindows(root string) string <span class="cov8" title="1">{
        return filepath.Join(root, "AppData", "LocalLow", "Dionic Software", "InfraSpace", "saves")
}</span>

func readSaveFile(path string) (string, []byte, error) <span class="cov8" title="1">{
        buf, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>
        <span class="cov8" title="1">fullSave := string(buf)
        i := strings.Index(fullSave, "{")
        if i &lt; 0 </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("could not find start of json-body")
        }</span>
        <span class="cov8" title="1">return fullSave[:i], []byte(fullSave[i:]), nil</span>
}

func maxBuildingStorage(building Building) Building <span class="cov0" title="0">{
        if building.ConsumerProducer == nil </span><span class="cov0" title="0">{
                return building
        }</span>
        <span class="cov0" title="0">for i := range building.ConsumerProducer.IncomingStorage </span><span class="cov0" title="0">{
                building.ConsumerProducer.IncomingStorage[i] = BUILDING_MAX_STORAGE
        }</span>
        <span class="cov0" title="0">return building</span>
}

func marshalJSON(v any) (string, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        enc := json.NewEncoder(buf)

        enc.SetEscapeHTML(false)
        enc.SetIndent("", "  ")

        err := enc.Encode(v)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
